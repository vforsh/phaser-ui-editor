import { controlContract } from '@tekton/control-rpc-contract'
import { mkdir, writeFile } from 'node:fs/promises'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { zodToJsonSchema } from 'zod-to-json-schema'

type FieldDoc = {
	name: string
	description: string
}

const GENERATED_HEADER = `// This file is auto-generated by scripts/generate-control-methods.ts. Do not edit.\n`

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const GENERATED_DIR = path.resolve(__dirname, '..', 'src', '__generated__')
const GENERATED_FILE = path.join(GENERATED_DIR, 'control-methods.ts')

function normalizeDoc(value: unknown): string {
	if (typeof value !== 'string') {
		return ''
	}

	return value.replace(/\s+/g, ' ').trim()
}

function getInputSchema(commandInput: unknown) {
	return zodToJsonSchema(commandInput, { $refStrategy: 'none' })
}

function getInputFieldDocs(commandInput: unknown): FieldDoc[] {
	const schema = getInputSchema(commandInput)
	if (!schema || typeof schema !== 'object') {
		return []
	}

	const properties = 'properties' in schema && schema.properties ? schema.properties : null
	if (!properties || typeof properties !== 'object') {
		return []
	}

	return Object.keys(properties)
		.sort()
		.map((name) => {
			const property = properties[name]
			const description = normalizeDoc(property?.description)
			if (!description) {
				return null
			}
			return { name, description }
		})
		.filter((entry): entry is FieldDoc => Boolean(entry))
}

function isEmptyInputSchema(commandInput: unknown): boolean {
	const schema = getInputSchema(commandInput)
	if (!schema || typeof schema !== 'object') {
		return false
	}

	if ('anyOf' in schema || 'oneOf' in schema || 'allOf' in schema) {
		return false
	}

	if ('type' in schema && schema.type !== 'object') {
		return false
	}

	const properties = 'properties' in schema && schema.properties ? schema.properties : null
	if (!properties || typeof properties !== 'object') {
		return 'type' in schema && schema.type === 'object'
	}

	return Object.keys(properties).length === 0
}

function buildMethodBlock(method: string, command: (typeof controlContract)[keyof typeof controlContract]): string[] {
	const description = normalizeDoc(command.description) || `Control RPC method: ${method}.`
	const fieldDocs = getInputFieldDocs(command.input)
	const isNoInput = isEmptyInputSchema(command.input)

	const lines: string[] = []
	lines.push('\t/**')
	lines.push(`\t * ${description}`)
	lines.push('\t *')
	lines.push(`\t * @group ${command.group}`)
	lines.push(`\t * @kind ${command.kind}`)
	for (const field of fieldDocs) {
		lines.push(`\t * @param input.${field.name} ${field.description}`)
	}
	lines.push('\t */')

	if (isNoInput) {
		lines.push(`\t${method}(): Promise<ControlOutput<'${method}'>>`)
	} else {
		lines.push(`\t${method}(input: ControlInput<'${method}'>): Promise<ControlOutput<'${method}'>>`)
	}

	return lines
}

export async function generateControlMethods(): Promise<void> {
	const methods = Object.keys(controlContract).sort()
	const lines: string[] = []

	lines.push(GENERATED_HEADER.trimEnd())
	lines.push("import type { ControlInput, ControlOutput } from '@tekton/control-rpc-contract'")
	lines.push("import type { EditorctlClient } from '../client'")
	lines.push('')
	lines.push('export interface GeneratedControlMethods {')

	for (const method of methods) {
		const command = controlContract[method as keyof typeof controlContract]
		lines.push(...buildMethodBlock(method, command))
		lines.push('')
	}

	lines.push('}')
	lines.push('')
	lines.push('export type EditorctlClientWithControlMethods = EditorctlClient & GeneratedControlMethods')
	lines.push('')

	await mkdir(GENERATED_DIR, { recursive: true })
	await writeFile(GENERATED_FILE, `${lines.join('\n')}`)
}

const isMain = process.argv[1] && path.resolve(process.argv[1]) === fileURLToPath(import.meta.url)
if (isMain) {
	generateControlMethods().catch((error) => {
		console.error(error)
		process.exitCode = 1
	})
}
